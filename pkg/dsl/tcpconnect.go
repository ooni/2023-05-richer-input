package dsl

import (
	"context"
	"encoding/json"
	"time"

	"github.com/ooni/probe-engine/pkg/measurexlite"
)

// TCPConnectOption is an option for [TCPConnect].
type TCPConnectOption func(operation *tcpConnectOperation)

// TCPConnectOptionTags allows configuring tags to include into measurements
// generated by the [TCPConnect] pipeline stage.
func TCPConnectOptionTags(tags ...string) TCPConnectOption {
	return func(operation *tcpConnectOperation) {
		operation.Tags = append(operation.Tags, tags...)
	}
}

// TCPConnect returns a stage that performs a TCP connect.
//
// This function returns an [ErrTCPConnect] if the error is a TCP connect error. Remember to
// use the [IsErrTCPConnect] predicate when setting an experiment test keys.
func TCPConnect(options ...TCPConnectOption) Stage[*Endpoint, *TCPConnection] {
	operation := &tcpConnectOperation{
		Tags: []string{},
	}
	for _, option := range options {
		option(operation)
	}
	return wrapOperation[*Endpoint, *TCPConnection](operation)
}

type tcpConnectOperation struct {
	Tags []string `json:"tags,omitempty"`
}

const tcpConnectStageName = "tcp_connect"

// ASTNode implements operation.
func (op *tcpConnectOperation) ASTNode() *SerializableASTNode {
	// Note: we serialize the structure because this gives us forward compatibility (i.e., we
	// may add a field to a future version without breaking the AST structure and old probes will
	// be fine as long as the zero value of the new field is the default)
	return &SerializableASTNode{
		StageName: tcpConnectStageName,
		Arguments: op,
		Children:  []*SerializableASTNode{},
	}
}

type tcpConnectLoader struct{}

// Load implements ASTLoaderRule.
func (*tcpConnectLoader) Load(loader *ASTLoader, node *LoadableASTNode) (RunnableASTNode, error) {
	var op tcpConnectOperation
	if err := json.Unmarshal(node.Arguments, &op); err != nil {
		return nil, err
	}
	if err := loader.RequireExactlyNumChildren(node, 0); err != nil {
		return nil, err
	}
	stage := wrapOperation[*Endpoint, *TCPConnection](&op)
	return &StageRunnableASTNode[*Endpoint, *TCPConnection]{stage}, nil
}

// StageName implements ASTLoaderRule.
func (*tcpConnectLoader) StageName() string {
	return tcpConnectStageName
}

// Run implements operation.
func (op *tcpConnectOperation) Run(ctx context.Context, rtx Runtime, endpoint *Endpoint) (*TCPConnection, error) {
	// create trace
	trace := rtx.NewTrace(op.Tags...)

	// start the operation logger
	ol := measurexlite.NewOperationLogger(
		rtx.Logger(),
		"[#%d] TCPConnect %s",
		trace.Index(),
		endpoint.Address,
	)

	// setup
	const timeout = 15 * time.Second
	ctx, cancel := context.WithTimeout(ctx, timeout)
	defer cancel()

	// obtain the dialer to use
	dialer := trace.NewDialerWithoutResolver()

	// connect
	conn, err := dialer.DialContext(ctx, "tcp", endpoint.Address)

	// stop the operation logger
	ol.Stop(err)

	// save observations
	rtx.SaveObservations(trace.ExtractObservations()...)

	// handle the error case
	if err != nil {
		rtx.Metrics().Error(tcpConnectStageName)
		return nil, &ErrTCPConnect{err}
	}

	// make sure we close the conn when done
	rtx.TrackCloser(conn)

	// prepare the return value
	rtx.Metrics().Success(tcpConnectStageName)
	out := &TCPConnection{
		Address: endpoint.Address,
		Conn:    conn,
		Domain:  endpoint.Domain,
		Trace:   trace,
	}
	return out, nil
}
