package minidsl

import (
	"context"
	"time"

	"github.com/ooni/probe-engine/pkg/measurexlite"
)

// DomainName returns a [Stage] that generates a domain name.
func DomainName(value string) Stage[*Void, string] {
	return &domainNameStage{value}
}

type domainNameStage struct {
	value string
}

// Run implements Stage.
func (sx *domainNameStage) Run(ctx context.Context, rtx Runtime, input Maybe[*Void]) Maybe[string] {
	if input.Error != nil {
		return NewError[string](input.Error)
	}
	return NewValue(sx.value)
}

// DNSLookupResult is the successful result of a [Stage] performing DNS lookups.
type DNSLookupResult struct {
	// Domain is the domain we tried to resolve.
	Domain string

	// Addresses contains resolved addresses (if any).
	Addresses []string
}

// DNSLookupUDP returns a [Stage] that performs DNS lookups using the given UDP endpoint. The
// endpoint format is "<IP>:<PORT>" for IPv4 and "[<IP>]:<PORT>" for IPv6.
func DNSLookupUDP(endpoint string) Stage[string, *DNSLookupResult] {
	return wrapOperation[string, *DNSLookupResult](&dnsLookupUDPStage{endpoint})
}

type dnsLookupUDPStage struct {
	endpoint string
}

func (sx *dnsLookupUDPStage) Run(ctx context.Context, rtx Runtime, domain string) (*DNSLookupResult, error) {
	// create trace
	trace := rtx.NewTrace()

	// start the operation logger
	ol := measurexlite.NewOperationLogger(
		rtx.Logger(),
		"[#%d] DNSLookupUDP endpoint=%s domain=%s",
		trace.Index(),
		sx.endpoint,
		domain,
	)

	// setup
	ctx, cancel := context.WithTimeout(ctx, 4*time.Second)
	defer cancel()

	// instantiate resolver
	resolver := trace.NewParallelUDPResolver(sx.endpoint)

	// do the lookup
	addrs, err := resolver.LookupHost(ctx, domain)

	// stop the operation logger
	ol.Stop(err)

	// save observations
	rtx.SaveObservations(trace.ExtractObservations()...)

	// handle the error case
	if err != nil {
		return nil, err
	}

	// handle the successful case
	return &DNSLookupResult{Domain: domain, Addresses: addrs}, nil
}

// DNSLookupGetaddrinfo is like [DNSLookupUDP] but uses the standard library resolver, which
// eventually calls getaddrinfo unless you compiled using the `-tags netgo` flag.
func DNSLookupGetaddrinfo() Stage[string, *DNSLookupResult] {
	return wrapOperation[string, *DNSLookupResult](&dnsLookupGetaddrinfoStage{})
}

type dnsLookupGetaddrinfoStage struct{}

func (sx *dnsLookupGetaddrinfoStage) Run(ctx context.Context, rtx Runtime, domain string) (*DNSLookupResult, error) {
	// create trace
	trace := rtx.NewTrace()

	// start the operation logger
	ol := measurexlite.NewOperationLogger(
		rtx.Logger(),
		"[#%d] DNSLookupGetaddrinfo domain=%s",
		trace.Index(),
		domain,
	)

	// setup
	ctx, cancel := context.WithTimeout(ctx, 4*time.Second)
	defer cancel()

	// instantiate a resolver
	resolver := trace.NewStdlibResolver()

	// do the lookup
	addrs, err := resolver.LookupHost(ctx, domain)

	// stop the operation logger
	ol.Stop(err)

	// save observations
	rtx.SaveObservations(trace.ExtractObservations()...)

	// handle the error case
	if err != nil {
		return nil, err
	}

	// handle the successful case
	return &DNSLookupResult{Domain: domain, Addresses: addrs}, nil
}

// DNSLookupStatic is like [DNSLookupGetaddinfo] but always returns a static list of addresses.
func DNSLookupStatic(addresses ...string) Stage[string, *DNSLookupResult] {
	return wrapOperation[string, *DNSLookupResult](&dnsLookupStaticStage{addresses})
}

type dnsLookupStaticStage struct {
	addresses []string
}

func (sx *dnsLookupStaticStage) Run(ctx context.Context, rtx Runtime, domain string) (*DNSLookupResult, error) {
	output := &DNSLookupResult{
		Domain:    domain,
		Addresses: sx.addresses,
	}
	return output, nil
}

// DNSLookupParallel runs several DNS lookup [Stage] using a pool of goroutines. This stage
// discards the errors generated by the [Stage] it runs. In case all [Stage] fail, the result
// Addresses field will contain an empty list of resolved IP addresses.
func DNSLookupParallel(stages ...Stage[string, *DNSLookupResult]) Stage[string, *DNSLookupResult] {
	return &dnsLookupParallelStage{stages}
}

type dnsLookupParallelStage struct {
	stages []Stage[string, *DNSLookupResult]
}

func (sx *dnsLookupParallelStage) Run(ctx context.Context, rtx Runtime, input Maybe[string]) Maybe[*DNSLookupResult] {
	if input.Error != nil {
		return NewError[*DNSLookupResult](input.Error)
	}

	// create list of workers to run
	var workers []Worker[Maybe[*DNSLookupResult]]
	for _, fx := range sx.stages {
		workers = append(workers, &dnsLookupParallelWorker{input: input, sx: fx, rtx: rtx})
	}

	// run workers
	const parallelism = 5
	results := ParallelRun(ctx, parallelism, workers...)

	// make sure we remove duplicate entries
	uniq := make(map[string]int)
	for _, result := range results {
		if result.Error != nil {
			continue
		}
		for _, address := range result.Value.Addresses {
			uniq[address]++
		}
	}

	// create the output and return it
	output := &DNSLookupResult{
		Domain:    input.Value,
		Addresses: nil,
	}
	for address := range uniq {
		output.Addresses = append(output.Addresses, address)
	}
	return NewValue(output)
}

// dnsLookupParallelWorker is a [Worker] run by [dnsLookupParallelStage].
type dnsLookupParallelWorker struct {
	input Maybe[string]
	rtx   Runtime
	sx    Stage[string, *DNSLookupResult]
}

func (w *dnsLookupParallelWorker) Produce(ctx context.Context) Maybe[*DNSLookupResult] {
	return w.sx.Run(ctx, w.rtx, w.input)
}
