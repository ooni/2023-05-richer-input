package main

import (
	"fmt"
	"io"
	"os"
	"sync"
	"time"

	"github.com/apex/log"
	"github.com/apex/log/handlers/json"
	"github.com/ooni/2023-05-richer-input/pkg/modelx"
	"github.com/ooni/probe-engine/pkg/logx"
	"github.com/ooni/probe-engine/pkg/model"
)

// ProgressOutput defines how the probe emits progress output while
// running nettests. We care about collecting logs, which may be
// emitted on the standard output or redirected towards a specific
// log file. We also care about showing progress.
type ProgressOutput interface {
	// This structure implements [model.Logger] to
	// collect and save/show logs.
	model.Logger

	// This structure implements [modelx.ProgressView] to
	// collect and show progress information.
	modelx.ProgressView

	// This structure implements [io.Closer] such that
	// the caller can close the resources it use when
	// we're done running nettests.
	io.Closer

	// This structure implements [io.Writer] such that
	// we can intercept and emit the events generated by
	// the [log] package in the standard library.
	io.Writer
}

// NewProgressOutput creates a new [ProgressOutput] instance. We use
// the given arguments to select the proper implementation.
func NewProgressOutput(logfile string, verbose bool) (ProgressOutput, error) {
	if logfile != "" {
		return newProgressOutputWithLogfile(logfile, verbose)
	}
	return newProgressOutputStdout(verbose)
}

// progressOutputStdout is a [ProgressOutput] emitting both logs
// and progress information on the standard output.
type progressOutputStdout struct {
	*log.Logger
}

// newProgressOutputStdout creates a new [progressOutputStdout].
func newProgressOutputStdout(verbose bool) (*progressOutputStdout, error) {
	// create the handler
	handler := &logx.Handler{
		Emoji:     true,
		Now:       time.Now,
		StartTime: time.Now(),
		Writer:    os.Stdout,
	}

	// create the logger
	logger := &log.Logger{Level: log.InfoLevel, Handler: handler}
	if verbose {
		logger.Level = log.DebugLevel
	}

	// return to the caller
	pos := &progressOutputStdout{logger}
	return pos, nil
}

var _ ProgressOutput = &progressOutputStdout{}

// Close implements ProgressOutput.
func (pos *progressOutputStdout) Close() error {
	return os.Stdout.Sync()
}

// SetNettest implements ProgressOutput.
func (pos *progressOutputStdout) SetNettest(nettest string) {
	// nothing
}

// SetProgress implements ProgressOutput.
func (pos *progressOutputStdout) SetProgress(progress float64) {
	pos.Logger.Infof("PROGRESS: %.2f%%", progress*100)
}

// SetSuite implements ProgressOutput.
func (pos *progressOutputStdout) SetSuite(suite string) {
	// nothing
}

// Write implements io.Writer
func (pos *progressOutputStdout) Write(line []byte) (n int, err error) {
	pos.Logger.Info(string(line))
	return len(line), nil
}

// progressOutputWithLogfile is a [ProgressOutput] where we know
// that we're writing the logs into a logfile.
type progressOutputWithLogfile struct {
	// Logger is the embedded log.Logger.
	*log.Logger

	// fp is the logfile.
	fp *os.File

	// mu provides mutual exclusion.
	mu sync.Mutex

	// nettest is the current nettest.
	nettest string

	// suite is the current suite.
	suite string

	// once provides "once" semantics for Close.
	once sync.Once
}

// newProgressOutputWithLogfile creates a [progressOutputWithLogfile]
func newProgressOutputWithLogfile(logfile string, verbose bool) (*progressOutputWithLogfile, error) {
	// open the logfile
	fp, err := os.OpenFile(logfile, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0600)
	if err != nil {
		return nil, err
	}

	// create the handler
	handler := json.New(fp)

	// create the logger
	logger := &log.Logger{Level: log.InfoLevel, Handler: handler}
	if verbose {
		logger.Level = log.DebugLevel
	}

	// create the structure
	powl := &progressOutputWithLogfile{
		Logger: logger,
		fp:     fp,
		once:   sync.Once{},
	}

	// return to the caller
	return powl, nil
}

// Close implements io.Closer
func (powl *progressOutputWithLogfile) Close() (err error) {
	powl.once.Do(func() {
		err = powl.fp.Close()
	})
	return
}

// SetNettest implements ProgressOutput.
func (powl *progressOutputWithLogfile) SetNettest(nettest string) {
	defer powl.mu.Unlock()
	powl.mu.Lock()
	powl.nettest = nettest
}

// SetProgress implements ProgressOutput.
func (powl *progressOutputWithLogfile) SetProgress(progress float64) {
	defer powl.mu.Unlock()
	powl.mu.Lock()
	fmt.Fprintf(
		os.Stdout,
		"%10d%% %s\n",
		int64(progress*100),
		powl.nettest,
	)
}

// SetSuite implements ProgressOutput.
func (powl *progressOutputWithLogfile) SetSuite(suite string) {
	defer powl.mu.Unlock()
	powl.mu.Lock()
	powl.suite = suite
	fmt.Fprintf(
		os.Stdout,
		"\n* %s:\n\n",
		powl.suite,
	)
}

// Write implements io.Writer
func (powl *progressOutputWithLogfile) Write(line []byte) (n int, err error) {
	powl.Logger.Info(string(line))
	return len(line), nil
}
